<!DOCTYPE html>
<html>

<head>
    <title>避け避けゲーム</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* 共通スタイル */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            background-color: #222;
            background-image:
                url('https://flowerillust.com/img/flower/flower-back1262.jpg');
            background-repeat: repeat;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* 画面全体を覆う */
        }

        #gameArea {
            position: relative;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
        }

        .block {
            background-color: #e74c3c;
            position: absolute;
            border-radius: 3px;
            animation: blockFall 1s linear infinite;
        }

        @keyframes blockFall {

            0%,
            100% {
                transform: translateY(0) rotate(0);
            }

            50% {
                transform: translateY(-5px) rotate(5deg);
            }
        }

        #player {
            background-color: #3498db;
            position: absolute;
            bottom: 10px;
            border-radius: 5px;
            transition: transform 0.1s ease;
            /* transformプロパティのアニメーション */
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            transition: opacity 0.5s ease;
            opacity: 0;
            z-index: 10;
        }

        .screen.show {
            opacity: 1;
        }

        #startScreen button,
        #resultScreen button {
            padding: 15px 30px;
            margin-top: 30px;
            background-color: #2ecc71;
            border: none;
            color: white;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        #startScreen button:hover,
        #resultScreen button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        #scoreContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
        }

        #waveContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
        }

        /* スマホ用スタイル (画面幅が768px以下の場合) */
        @media (max-width: 768px) {
            #gameArea {
                width: 95vw;
                height: 60vh;
            }

            .block {
                width: 30px;
                height: 30px;
            }

            #player {
                width: 60px;
                height: 10px;
            }

            #startScreen button,
            #resultScreen button {
                font-size: 0.8em;
            }

            #scoreContainer,
            #waveContainer {
                font-size: 1em;
            }
        }

        /* PC用スタイル (画面幅が768pxより大きい場合) */
        @media (min-width: 768px) {
            #gameArea {
                width: 800px;
                /* 幅を大きく */
                height: 600px;
                /* 高さを大きく */
            }

            .block {
                width: 50px;
                /* ブロックの幅を大きく */
                height: 50px;
                /* ブロックの高さを大きく */
            }

            #player {
                width: 100px;
                /* プレイヤーの幅を大きく */
                height: 15px;
                /* プレイヤーの高さを少し大きく */
            }

            #startScreen button,
            #resultScreen button {
                font-size: 1.2em;
                /* ボタンのフォントサイズを大きく */
            }

            #scoreContainer,
            #waveContainer {
                font-size: 1.5em;
                /* スコアとウェーブのフォントサイズを大きく */
            }
        }

        /* イベント発生時の背景色 */
        .event-background {
            animation: eventBackground 1s linear infinite;
        }

        @keyframes eventBackground {
            0% {
                background-color: #eee;
            }

            50% {
                background-color: #f0f0f0;
            }

            100% {
                background-color: #eee;
            }
        }

        /* 高速ブロック */
        .fast-block {
            background-color: #9b59b6;
            animation: fastBlockFall 0.5s linear infinite;
        }

        @keyframes fastBlockFall {

            0%,
            100% {
                transform: translateY(0) rotate(0);
            }

            50% {
                transform: translateY(-10px) rotate(10deg);
            }
        }

        /* 低速ブロック */
        .slow-block {
            background-color: #2980b9;
            animation: slowBlockFall 2s linear infinite;
        }

        @keyframes slowBlockFall {

            0%,
            100% {
                transform: translateY(0) rotate(0);
            }

            50% {
                transform: translateY(-2px) rotate(2deg);
            }
        }

        /* バリア */
        .barrier {
            box-shadow: 0 0 10px 5px #ffff00;
            /* バリアの見た目を設定 (例: 黄色い光) */
        }
    </style>
</head>

<body>
    <div id="gameArea">
        <div id="scoreContainer" style="color:black">スコア: <span id="score">0</span></div>
        <div id="waveContainer" style="color:black">Wave: <span id="wave">1</span></div>
        <div id="player"></div>
        <div id="startScreen" class="screen show">
            <h1>避け避けゲームv1</h1>
            <button id="startGame">ゲームスタート</button>
        </div>
        <div id="resultScreen" class="screen">
            <h2>ゲームオーバー！</h2>
            <p>スコア: <span id="finalScore"></span></p>
            <p>ハイスコア: <span id="highScore"></span></p>
            <button id="restartGame">再挑戦</button>
            <button id="resetHighScore">ハイスコアをリセット</button>
        </div>
    </div>

    <!-- Howler.jsを読み込む -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

    <script type="module">

        // Js File

        // ZzFX - Zuper Zmall Zound Zynth - Micro Edition
            // MIT License - Copyright 2019 Frank Force
            // https://github.com/KilledByAPixel/ZzFX

            // This is a minified build of zzfx for use in size coding projects.
            // You can use zzfxV to set volume.
            // Feel free to minify it further for your own needs!

            'use strict';

            ///////////////////////////////////////////////////////////////////////////////

            // ZzFXMicro - Zuper Zmall Zound Zynth - v1.3.0 by Frank Force

            // ==ClosureCompiler==
            // @compilation_level ADVANCED_OPTIMIZATIONS
            // @output_file_name ZzFXMicro.min.js
            // @js_externs zzfx, zzfxG, zzfxP, zzfxV, zzfxX
            // @language_out ECMASCRIPT_2019
            // ==/ClosureCompiler==

            const zzfx = (...z) => zzfxP(zzfxG(...z)); // generate and play sound
            const zzfxV = .3;    // volume
            const zzfxR = 44100; // sample rate
            const zzfxX = new AudioContext; // audio context
            const zzfxP = (...samples) =>  // play samples
            {
                // create buffer and source
                let buffer = zzfxX.createBuffer(samples.length, samples[0].length, zzfxR),
                    source = zzfxX.createBufferSource();

                // copy samples to buffer and play
                samples.map((d, i) => buffer.getChannelData(i).set(d));
                source.buffer = buffer;
                source.connect(zzfxX.destination);
                source.start();
                return source;
            }
            const zzfxG = // generate samples
                (
                    // parameters
                    volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0,
                    release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0,
                    pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0,
                    bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, tremolo = 0, filter = 0
                ) => {
                    // init parameters
                    let PI2 = Math.PI * 2, sign = v => v < 0 ? -1 : 1,
                        startSlide = slide *= 500 * PI2 / zzfxR / zzfxR,
                        startFrequency = frequency *=
                            (1 + randomness * 2 * Math.random() - randomness) * PI2 / zzfxR,
                        b = [], t = 0, tm = 0, i = 0, j = 1, r = 0, c = 0, s = 0, f, length,

                        // biquad LP/HP filter
                        quality = 2, w = PI2 * Math.abs(filter) * 2 / zzfxR,
                        cos = Math.cos(w), alpha = Math.sin(w) / 2 / quality,
                        a0 = 1 + alpha, a1 = -2 * cos / a0, a2 = (1 - alpha) / a0,
                        b0 = (1 + sign(filter) * cos) / 2 / a0,
                        b1 = -(sign(filter) + cos) / a0, b2 = b0,
                        x2 = 0, x1 = 0, y2 = 0, y1 = 0;

                    // scale by sample rate
                    attack = attack * zzfxR + 9; // minimum attack to prevent pop
                    decay *= zzfxR;
                    sustain *= zzfxR;
                    release *= zzfxR;
                    delay *= zzfxR;
                    deltaSlide *= 500 * PI2 / zzfxR ** 3;
                    modulation *= PI2 / zzfxR;
                    pitchJump *= PI2 / zzfxR;
                    pitchJumpTime *= zzfxR;
                    repeatTime = repeatTime * zzfxR | 0;
                    volume *= zzfxV;

                    // generate waveform
                    for (length = attack + decay + sustain + release + delay | 0;
                        i < length; b[i++] = s * volume)               // sample
                    {
                        if (!(++c % (bitCrush * 100 | 0)))                   // bit crush
                        {
                            s = shape ? shape > 1 ? shape > 2 ? shape > 3 ?      // wave shape
                                Math.sin(t * t) :                        // 4 noise
                                Math.max(Math.min(Math.tan(t), 1), -1) :  // 3 tan
                                1 - (2 * t / PI2 % 2 + 2) % 2 :                     // 2 saw
                                1 - 4 * Math.abs(Math.round(t / PI2) - t / PI2) : // 1 triangle
                                Math.sin(t);                           // 0 sin

                            s = (repeatTime ?
                                1 - tremolo + tremolo * Math.sin(PI2 * i / repeatTime) // tremolo
                                : 1) *
                                sign(s) * (Math.abs(s) ** shapeCurve) *      // curve
                                (i < attack ? i / attack :                 // attack
                                    i < attack + decay ?                     // decay
                                        1 - ((i - attack) / decay) * (1 - sustainVolume) : // decay falloff
                                        i < attack + decay + sustain ?          // sustain
                                            sustainVolume :                          // sustain volume
                                            i < length - delay ?                     // release
                                                (length - i - delay) / release *           // release falloff
                                                sustainVolume :                          // release volume
                                                0);                                      // post release

                            s = delay ? s / 2 + (delay > i ? 0 :           // delay
                                (i < length - delay ? 1 : (length - i) / delay) * // release delay 
                                b[i - delay | 0] / 2 / volume) : s;              // sample delay

                            if (filter)                                   // apply filter
                                s = y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = s) - a2 * y2 - a1 * (y2 = y1);
                        }

                        f = (frequency += slide += deltaSlide) *// frequency
                            Math.cos(modulation * tm++);          // modulation
                        t += f + f * noise * Math.sin(i ** 5);        // noise

                        if (j && ++j > pitchJumpTime)           // pitch jump
                        {
                            frequency += pitchJump;             // apply pitch jump
                            startFrequency += pitchJump;        // also apply to start
                            j = 0;                              // stop pitch jump time
                        }

                        if (repeatTime && !(++r % repeatTime))  // repeat
                        {
                            frequency = startFrequency;         // reset frequency
                            slide = startSlide;                 // reset slide
                            j = j || 1;                         // reset pitch jump time
                        }
                    }

                    return b;
                }


                //JSfile Out
        
        

        // jsfxrで効果音を生成 
        const barrierSoundData = zzfx(...[1, 0, 262, 0.03, 0.3, 0.48, 1, 1.73, -0.81, 0.18, 0.02, 0, 0, 0, 0, 0.06, 0.24]); // バリア付与音
        const barrierBreakSoundData = zzfx(...[2, 0, 196, 0.02, 0.28, 0.43, 1, 0.99, 0, -0.59, 0.15, 0, 0, 0, 0, 0.07, 0.13]); // バリア破壊音
        const gameOverSoundData = zzfx(...[2, 0, 80, 0.03, 0.2, 0.3, 1, 0.73, 0, 0.34, 0.17, 0, 0, 0, 0, 0.14, 0.07]); // ゲームオーバー音
        const eventStartSoundData = zzfx(...[1, 0, 400, 0.02, 0.1, 0.4, 1, 1.94, 0.23, -0.63, 0.11, 0, 0, 0, 0, 0.09, 0.24]); // イベント開始音

        // Howler.jsで効果音を再生
        const barrierSound = new Howl({
            src: [barrierSoundData],
            format: 'wav'
        });

        const barrierBreakSound = new Howl({
            src: [barrierBreakSoundData],
            format: 'wav'
        });

        const gameOverSound = new Howl({
            src: [gameOverSoundData],
            format: 'wav'
        });

        const eventStartSound = new Howl({
            src: [eventStartSoundData],
            format: 'wav'
        });

        const gameArea = document.getElementById('gameArea');
        const player = document.getElementById('player');
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const highScoreElement = document.getElementById('highScore');
        const scoreElement = document.getElementById('score');
        const waveElement = document.getElementById('wave');
        let playerX;
        let score = 0;
        let wave = 1;
        let highScore = localStorage.getItem('highScore') || 0;
        let blockSpeed = 5;
        let blocks = [];
        let maxBlocks = 1;
        let startTime;
        let waveDuration = 10000;
        let gameOver = false; // gameOverフラグを追加
        let isEventActive = false; // イベント発生中フラグ
        let hasBarrier = false; // バリア所持フラグ


        function initGame() {
            playerX = (gameArea.offsetWidth - player.offsetWidth) / 2;
            score = 0;
            wave = 1;
            blockSpeed = 5;
            gameOver = false; // ゲーム開始時にフラグをfalseに設定
            isEventActive = false; // イベント発生中フラグをfalseに設定
            hasBarrier = false; // ゲーム開始時にバリア所持フラグをfalseに設定
            scoreElement.textContent = score;
            waveElement.textContent = wave;
            player.style.transform = `translateX(${playerX}px)`;
            gameArea.classList.remove('event-background'); // イベント発生時の背景色をリセット
            player.classList.remove('barrier'); // バリアのクラスを削除

            startScreen.style.display = 'none';

            blocks.forEach(block => block.remove());
            blocks = [];

            maxBlocks = 1;
            for (let i = 0; i < maxBlocks; i++) {
                createBlock();
            }

            startTime = Date.now();
        }

        function createBlock() {
            const block = document.createElement('div');
            block.classList.add('block');

            // イベント発生中なら特別なブロックを生成
            if (isEventActive) {
                const eventTypes = ['fast', 'slow'];
                const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                block.classList.add(`${eventType}-block`);
            }

            resetBlockPosition(block);
            gameArea.appendChild(block);
            blocks.push(block);
        }

        function moveBlocks() {
            blocks.forEach((block) => {
                let blockY = block.offsetTop + (block.classList.contains('fast-block') ? blockSpeed * 2 : (block.classList.contains('slow-block') ? blockSpeed * 0.5 : blockSpeed));
                block.style.top = blockY + 'px';

                if (blockY > gameArea.clientHeight - block.offsetHeight) {
                    resetBlockPosition(block);
                    updateScore(score + 1);
                }

                if (checkCollision(block)) {
                    gameOver = true;
                    showResult();
                    return;
                }
            });
        }

        function resetBlockPosition(block) {
            block.style.left = Math.floor(Math.random() * (gameArea.clientWidth - block.offsetWidth)) + 'px';
            block.style.top = -block.offsetHeight + 'px';

            // イベント発生中でなければ特別なブロックのクラスを削除
            if (!isEventActive) {
                block.classList.remove('fast-block', 'slow-block');
            }
        }

        function nextWave() {
            wave++;
            waveElement.textContent = wave;
            blockSpeed *= 1.1;
            maxBlocks = Math.min(wave, 5);

            // ランダムにイベント発生
            if (Math.random() < 0.5) {
                startEvent();
            }

            // ランダムにバリア付与
            if (Math.random() < 0.3 && !hasBarrier) {
                grantBarrier();
            }

            while (blocks.length < maxBlocks) {
                createBlock();
            }
        }

        function checkCollision(block) {
            const playerRect = player.getBoundingClientRect();
            const blockRect = block.getBoundingClientRect();

            if (
                playerRect.bottom > blockRect.top &&
                playerRect.right > blockRect.left &&
                playerRect.left < blockRect.right &&
                playerRect.top < blockRect.bottom
            ) {
                if (hasBarrier) {
                    // バリアがある場合はバリアを消費して衝突を無効化
                    hasBarrier = false;
                    player.classList.remove('barrier'); // バリアのクラスを削除

                    // バリア破壊の効果音を再生
                    barrierBreakSound.play();

                    // 衝突したブロックを削除
                    block.remove();
                    blocks = blocks.filter(b => b !== block); // blocks配列からも削除

                    return false; // 衝突なしとして処理
                } else {
                    return true; // バリアがない場合は衝突ありとして処理
                }
            } else {
                return false; // 衝突なしとして処理
            }
        }

        function movePlayer(event) {
            if (event.key === 'a' && playerX > 0) {
                playerX -= 20;
            } else if (event.key === 'd' && playerX < gameArea.clientWidth - player.offsetWidth) {
                playerX += 20;
            }
            player.style.transform = `translateX(${playerX}px)`; // transformプロパティを更新
        }

        let touchStartX = 0;
        gameArea.addEventListener('touchstart', (event) => {
            const touchX = event.touches[0].clientX;
            const gameAreaRect = gameArea.getBoundingClientRect(); // ゲームエリアの位置情報を取得

            // ゲームエリアの左端の座標を考慮して touchStartX を計算
            touchStartX = touchX - gameAreaRect.left - player.offsetLeft;
        });

        gameArea.addEventListener('touchmove', (event) => {
            const touchX = event.touches[0].clientX;
            const gameAreaRect = gameArea.getBoundingClientRect();

            // ゲームエリアの左端の座標を考慮して playerX を計算
            playerX = touchX - gameAreaRect.left - player.offsetLeft;

            // プレイヤーの移動範囲を制限
            if (playerX < 0) {
                playerX = 0;
            } else if (playerX > gameArea.clientWidth - player.offsetWidth) {
                playerX = gameArea.clientWidth - player.offsetWidth;
            }

            player.style.transform = `translateX(${playerX}px)`; // transformプロパティを更新
        });

        function updateScore(newScore) {
            score = newScore;
            scoreElement.textContent = score;
        }

        function showResult() {
            gameOverSound.play(); // ゲームオーバー音を再生

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            finalScoreElement.textContent = score;
            highScoreElement.textContent = highScore;
            resultScreen.classList.add('show');
        }

        function resetHighScore() {
            localStorage.removeItem('highScore');
            highScore = 0;
            highScoreElement.textContent = highScore;
        }

        document.getElementById('startGame').addEventListener('click', () => {
            startScreen.classList.remove('show');
            initGame();
            gameLoop();
        });

        document.getElementById('restartGame').addEventListener('click', () => {
            resultScreen.classList.remove('show');
            initGame();
            gameLoop();
        });

        document.getElementById('resetHighScore').addEventListener('click', resetHighScore);

        document.addEventListener('keydown', movePlayer);
        highScoreElement.textContent = highScore;


        function startEvent() {
            isEventActive = true;
            gameArea.classList.add('event-background'); // 背景色を変更

            // イベント開始音を再生
            eventStartSound.play();

            // イベント終了タイマーを設定
            setTimeout(() => {
                isEventActive = false;
                gameArea.classList.remove('event-background'); // 背景色を元に戻す
            }, 5000); // 5秒後にイベント終了
        }

        function grantBarrier() {
            hasBarrier = true;
            player.classList.add('barrier'); // プレイヤーにバリアのクラスを追加 (見た目でバリアがわかるように)

            // バリアの効果音を再生
            barrierSound.play();
        }

        function gameLoop() {
            if (!gameOver) {
                moveBlocks();

                const elapsedTime = Date.now() - startTime;
                if (elapsedTime >= waveDuration) {
                    nextWave();
                    startTime = Date.now();
                }

                setTimeout(gameLoop, 30);
            }
        }
    </script>
</body>

</html>